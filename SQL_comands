-- команды для работы в SQL

psql postgres -- подключаешься к дефолтной базе данных постгрес.
CREATE DATABASE hexlet_db; -- тчк с запятой обязательно, это завершение команды.
psql hexlet_db -- подключаемся к бд hexlet_db.

-- создаем таблицу командой
-- все имена используются как пример

CREATE TABLE users (
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(255),
    created_at TIMESTAMP,
    birthday DATE
);

-- добавление пользователей в таблицу

INSERT INTO users
(first_name,  last_name, email, created_at, birthday)
VALUES ('Lucienne', 'Feil',  'Trevion53@yahoo.com', '2022-06-14 18:31:05.296', '2017-08-03');

INSERT INTO users
(first_name,  last_name, email, created_at, birthday)
VALUES ('Ramiro', 'Wolf',  'Baylee52@yahoo.com', '2022-06-14 02:04:13.104', '2000-03-23');

INSERT INTO users
(first_name,  last_name, email, created_at, birthday)
VALUES ('Maureen', 'Romaguera',  'Casimer_Cronin@yahoo.com', '2022-06-14 02:28:26.058', '2012-07-30');

-- что бы увидеть все таблицы \dt, затем \d имя_таблицы что бы увидеть ее структуру.

-- запрост на редактирование записи
UPDATE users SET email = 'Casimer_Cronin@gmail.com'
WHERE last_name = 'Romaguera';

-- удалени записи
DELETE FROM users WHERE last_name = 'Romaguera';

-- выбрать запись
SELECT * FROM users WHERE first_name = 'Ramiro';

-- удаление таблиц
DROP TABLE users;

-- "--" два дефиса это однострочный коментарий
/* и */ это для многострочных коментариев

-- Утилита PSQL
-- подключение к БД с помощью psql
psql -h server_address -U username -d dbname

-- урок 6
-- примеры
CREATE TABLE students (
    id BIGINT,
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    email VARCHAR(255),
    bio TEXT,
    is_studying BOOLEAN,
    updated_at TIMESTAMP,
    created_at TIMESTAMP
  );
-- решение задачи
CREATE TABLE events (
   id BIGINT,
   name VARCHAR(50),
   date DATE, time TIME,
   location VARCHAR(100),
   description TEXT);


-- урок 7
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(255),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

-- Наполняем таблицу данными
INSERT INTO users (id, created_at, email, first_name, last_name, username) VALUES (1, '2022-06-14 18:31:05.296', 'Trevion53@yahoo.com', 'Lucienne', 'Feil', 'Duncan3');
INSERT INTO users (id, created_at, email, first_name, last_name, username) VALUES (2, '2022-06-14 02:04:13.104', 'Baylee52@yahoo.com', 'Ramiro', 'Wolf', 'Michaela11');

-- создаем таблицу с автоинкрементом
CREATE TABLE users (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

-- Основной ключ и автоинкремент часто используются вместе

CREATE TABLE users (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

-- Просмотреть все записи (полностью)
SELECT * FROM users;

CREATE TABLE users (
    -- Одновременное использование и первичного ключа и автогенерации
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    created_at TIMESTAMP
);

-- задание к уроку 7
CREATE TABLE article_categories (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    name VARCHAR(50)
    );
INSERT INTO article_categories (name) VALUES ('Dave Grohl');
INSERT INTO article_categories (name) VALUES ('Kurt Cobain');

-- урок 8
SELECT * FROM users; -- Этот запрос достает все содержимое таблицы users.
SELECT username, email FROM users; --Если поля нужны не все, то достаточно перечислить их через запятую вместо звездочки.

-- практическое задание к уроку
/*Составьте запрос, который извлекает из таблицы companies:
company_name — названия компаний
url — адрес компаний в интернете*/

SELECT company_name, url FROM companies;

-- Урок 9
-- SELECT * FROM users WHERE ... Чтобы выбрать строки, которые нам нужны используют оператор WHERE
-- В запросе SELECT его нужно добавить и после него задать нужное нам условие.
-- SELECT * FROM users WHERE id > 60;
-- SELECT * FROM users WHERE id = 1;
-- SELECT * FROM users WHERE id != 3;
-- SELECT * FROM users WHERE first_name = 'Johan';
-- SELECT name, created_at FROM courses WHERE created_at > '2022-06-14';

-- выполнение практического задания

SELECT first_name, last_name FROM users WHERE birthday <= '2000-01-01';

-- урок 10 NULL

--SELECT * FROM users WHERE birthday IS NOT NULL;
--SELECT * FROM users WHERE created_at IS NULL;

-- Урок 11 примеры
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name = 'Schumm';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE '%man';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%t';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'sch%t';
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name ILIKE 'sch%t'; -- регистр не имеет значение
SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name NOT LIKE '%man';

-- задание из урока
SELECT first_name, last_name, email FROM users WHERE email LIKE '%google.com';

--Урок 12 (Регулярные выражения)
SELECT
    id,
    first_name,
    last_name,
    email,
    birthday
FROM users
WHERE first_name SIMILAR TO '[AB]%';

WHERE first_name SIMILAR TO '[AB]%'; -- выбрать пользователей, чье имя начинается на 'A' или 'B
WHERE username SIMILAR TO '%[a-z]'; -- вернет всех пользователей по условию: username заканчивается любой буквой
WHERE username SIMILAR TO '%[а-я]%' -- вернет всех пользователей по условию: username заканчивается любой буквой
WHERE username SIMILAR TO '%[0-9]'; -- вернет всех пользователей по условию: username заканчивается любой цифрой
FROM users WHERE email SIMILAR TO '%@%.%'; --проверим, что в поле email введены корректные адреса электронной почты.
FROM users WHERE email NOT SIMILAR TO '%@%.%'; -- частица NOT позволит найти строки, которые не соответствуют шаблону
FROM users WHERE email SIMILAR TO '%@%.__' -- Символ подчеркивания обозначает ровно один любой символ, необязательно букву
FROM users WHERE email SIMILAR TO '%.___'; --

-- упражнение к уроку
SELECT first_name, email FROM users WHERE telephone NOT SIMILAR TO '[0-9]{3}';

-- урок 13 Сложные условия фильтрации
SELECT *
FROM courses
WHERE body LIKE '%dolor%'
    AND created_at < '2022-06-14';/* ключевой оператор AND.информацию о курсах,
    --созданных до 14 июня 2022 года и содержащих слово dolor в описании */

SELECT *
FROM users
WHERE id > 90 OR id IS NULL; /* выбрать пользователей с идентификатором больше 90
и тех пользователей, у кого идентификатор не проставлен вовсе.*/


SELECT *
FROM users
WHERE first_name = 'Andy'
    OR (created_at > '2022-06-13' AND created_at < '2022-06-14'); /* Проверка в скобках имеет больший приоритет
    В этом запросе мы выберем либо пользователей с именем Andy, либо тех, кто зарегистрировался между 13 и 14 июня 2022 года.*/

-- упражнение к уроку

SELECT first_name, email
FROM users
WHERE
    created_at >= '2022-07-01'
    AND created_at <= '2022-07-31'
    AND email NOT SIMILAR TO '%@%\.%';

-- Урок 14

SELECT *
FROM users
WHERE birthday BETWEEN '2022-01-01' AND '2022-02-01'; -- выбирает пользователей с датой рождения от 1 января до 1 февраля 2022 года

SELECT *
FROM users
WHERE birthday NOT BETWEEN '2022-01-01' AND '2022-02-01'; -- все записи, которые НЕ попадают в диапазон.

-- Урок 15 оператор  IN

SELECT                           /* один запрос и найти пользователей
                                 с идентификаторами 1, 2 или 5. Для этого используют OR */
    id,
    first_name,
    last_name
FROM users
WHERE id = 1 OR id = 2 OR id = 5;


SELECT
    id,
    first_name,
    last_name
FROM users
WHERE id IN (1, 2, 5); -- что бы не городить OR-ы пишем IN.


SELECT id, first_name, last_name
FROM users
WHERE id NOT IN (1, 2, 5); -- Если нужно исключить определенные записи, достаточно добавить NOT перед IN.


SELECT id, first_name, last_name
FROM users
WHERE first_name IN ('Lionel', 'Lucienne', 'Jennyfer'); -- IN можно использовать с другими типами данных — например, со строками.

-- ПРАКТИЧЕСКОЕ ЗАНЯТИЕ К УРОКУ 15
SELECT title
FROM articles
WHERE creator_id IN (1, 4);

-- Урок 16 Оператор ORDER BY

SELECT                        -- Сортировка задается с помощью оператора ORDER BY
    id,
    username,
    created_at
FROM users ORDER BY username;


SELECT                         -- Сортировка по датам, отсортировали пользователей
    id,                        -- по дате создания в прямом порядке, то есть по возрастанию.
    username,
    created_at
FROM users ORDER BY created_at;

-- Прямой порядок сортировки
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at ASC;
-- То же самое, что и
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at;

-- Обратный порядок сортировки
SELECT
    id,
    username,
    created_at
FROM users
ORDER BY created_at DESC;

-- Сортировка по нескольким полям

SELECT                                   -- перечислить поля через запятую
    id,
    username,
    created_at
FROM users ORDER BY username, created_at;

-- Сортировка NULL-значений

-- Сортируем по возрастанию даты, то есть поля `created_at`
-- Поля с `NULL` идут первыми
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at ASC NULLS FIRST;

-- Сортируем по убыванию даты
-- Поля с `NULL` идут последними
SELECT
    id,
    username,
    created_at
FROM users ORDER BY created_at DESC NULLS LAST;

-- ПРАКТИЧЕСКОЕ ЗАНЯТИЕ К УРОКУ 16

SELECT
    first_name,
    last_name,
    salary
FROM staff ORDER BY salary DESC, first_name ASC;

-- Урок 17 Ограничение выборки
-- Чтобы ограничить выборку, используется LIMIT.

SELECT
    id,
    username,
    email
FROM users LIMIT 10; -- извлечь 10 записей.


SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10; -- Оператор LIMIT без сортировки практически никогда не используется

SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10 OFFSET 10; -- пагинацию — механизм, который позволяет перемещаться по страницам.

-- Выбрать записи с 21 по 30
SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10 OFFSET 20;

-- Выбрать записи с 31 по 40
SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10 OFFSET 30;

-- ПРАКТИЧЕСКОЕ ЗАНЯТИЕ К УРОКУ 17

-- Урок 18 Уникальные строки
-- oператор DISTINCT удаляет повторяющиеся строки запроса и оставляет только уникальные
SELECT DISTINCT course_id FROM course_members ORDER BY course_id;

-- DISTINCT добавляется в запрос только один раз,
-- независимо от того, сколько колонок перечисляется
SELECT DISTINCT
    course_id,
    user_id
FROM course_members ORDER BY course_id;

-- Оператор DISTINCT ON

SELECT DISTINCT course_id, created_at FROM course_members ORDER BY course_id;

SELECT DISTINCT ON (course_id) -- DISTINCT ON позволяет указать:
    course_id,                 -- Поле, которое должно быть уникальным.
    created_at                 -- Поля, которые нужно вывести.
FROM course_members
ORDER BY course_id, created_at;

-- В DISTINCT ON можно указывать несколько полей в качестве уникальных:
SELECT DISTINCT ON (course_id, created_at)
    course_id,
    created_at
FROM course_members
ORDER BY course_id;

-- Сортировка с оператором DISTINCT ON

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at DESC;

-- УРОК 19 АГРЕГАТНЫЕ ФУНКЦИИ

SELECT COUNT(*) FROM users; -- сколько записей содержится в таблице users
SELECT COUNT(id) FROM users; -- функция вернет нам количество строк, в которых поле НЕ равно NULL
SELECT COUNT(email_confirmed) FROM users; -- вернет 0 потому что в таблице поле email_confirmed не содержит никаких данных.
SELECT COUNT(*) FROM users WHERE gender = 'female'; -- вернет количество девушек среди всех пользователей.
SELECT SUM(spent_minutes) FROM course_reviews; --  возвращает сумму всех значений
-- Если передать поле, в котором хранятся строки или даты, то запрос вернет ошибку и символ * тоже вернет ошибку
SELECT AVG(spent_minutes) FROM course_reviews WHERE user_id = 9; -- Найдем среднее время, проведенное пользователем с id = 9 на площадке онлайн-школы
SELECT MAX(spent_minutes) FROM course_reviews;-- найти максимальное и
SELECT MIN(spent_minutes) FROM course_reviews; --минимальное значение соответственно
SELECT MIN(username) FROM users; --Для строк минимальное и максимальное значения — это первая и
SELECT MAX(username) FROM users; -- последняя строки, упорядоченные по алфавиту.

--ПРАКТИКА К УРОКУ 19
SELECT AVG (salary) FROM staff WHERE job_title = 'Engineer';

-- УРОК 20 Группировка по выборке
SELECT
    user_id,
    COUNT(*)
FROM course_members
GROUP BY user_id
ORDER BY user_id;

SELECT
    user_id AS student,
    COUNT(*) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;

SELECT
    user_id AS student,
    COUNT(user_id) AS courses_count,
    MAX(created_at) AS last_reg
FROM course_members
GROUP BY user_id
ORDER BY user_id;

-- ПРАКТИКА К УРОКУ 20

SELECT
    job_title,
    MAX (salary) AS max_salary,
    MIN (salary) AS min_salary
FROM staff
GROUP BY job_title
ORDER BY job_title;

-- УРОК 21 Фильтрация c помощью оператора HAVING
SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
GROUP BY user_id
HAVING SUM(spent_minutes) < 30 -- айти пользователей, которые потратили менее 30 минут в онлайн-школе
ORDER BY user_id;

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
WHERE user_id <= 40
GROUP BY user_id
HAVING SUM(spent_minutes) < 30 -- Условия в HAVING проверяются после группировки, поэтому они задаются после предложения GROUP BY
ORDER BY user_id;

-- ПРАКТИКА К УРОКУ 21

SELECT
  buyer_id,
  COUNT(*) AS orders_count,
  SUM(price) AS total_price
FROM orders
GROUP BY buyer_id
HAVING COUNT(*) >= 2
ORDER BY total_price DESC;

-- УРОК 22 ВСТАВКА И МОДИФИКАЦИЯ ДАННЫХ

INSERT — запрос на вставку данных
UPDATE — запрос на обновление данных
DELETE — запрос на удаление данных

INSERT INTO users (username, email, first_name, last_name, birthday, gender, id, created_at, password_digest)
VALUES ('AgentJ', 'wsmith09@gmail.com', 'Will', 'Smith', '1968-09-25', 'male', 100, '2023-05-01', '11111'); -- добавление записи

UPDATE users SET username = 'SuperAgent007' WHERE email = 'agent007@yahoo.com'; -- обновление запси.
UPDATE users SET first_name = 'Pierce', last_name = 'Brosnan' WHERE email = 'agent007@yahoo.com'; -- Порядок, в котором изменяются поля, — не важен:
UPDATE users SET first_name = 'John', last_name = 'Doe' ; -- Часть WHERE можно вообще не указывать.
-- Потеря условия WHERE может обернуться перезаписью важных данных.

-- Операции сравнения
Мы можем использовать любые математические операции сравнения: больше, меньше, не равно и другие.
UPDATE users SET first_name = 'John' WHERE birthday > '1970-01-01';

-- Логические операции Мы можем использовать логические операции для объединения условий: И и ИЛИ.
UPDATE users SET email = 'johndoe@yahoo.com'
  WHERE first_name = 'John' AND last_name = 'Doe';

UPDATE users SET first_name = 'John'
  WHERE birthday BETWEEN '1950-01-01' AND '2000-01-01';

UPDATE users SET username = 'secretagent' -- задаем приоритет с помошью скобок
WHERE
    (first_name = 'Sean' AND last_name = 'Connery') OR (birthday = '1968-09-25' AND gender = 'male');

DELETE FROM users                                    -- запрос удалит из таблицы users пользователя с идентификатором 100,
WHERE                                                -- а также все записи с датой, где дата рождения пользователя с 1968 года по 2000:
    (birthday BETWEEN '1968-01-01' AND '2000-01-01') -- с 1968 года по 2000.
    OR (id = 100);

DELETE FROM users; -- Если никакое условие указано не будет, то будут удалены все записи из указанной таблицы.
